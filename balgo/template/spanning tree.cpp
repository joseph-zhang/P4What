/**
*    生成树相关的问题往往可以转化为最小生成树的求解.
*    在讨论相关问题之前,先来了解一点知识:
*    对于边权互不相同的图G=(V,E),其生成树有性质：
*    (I)切割性质:
*        设S是V的既非空集又非全集的子集.e是一端在S内而另一端不在的边之中权值最小的一个.
*        则G所有的生成树都包含e.
*    (II)回路性质:
*        设C是G上的任意回路(有向圈),e是C上权值最大的边.
*        则G的所有生成树都不含e.
*/

/**
*    (一)增量最小生成树
*    从包含n个点的空图开始,依次加入m条带权边.每加入一条都要给出当前的图的最小生成树.
*    如果每次都求一遍最小生成树,复杂度挺高O(logn*m^2).
*    可以根据回路性质加以改进.每次求出最小生成树后,把图中其他的边都删掉.
*    时间复杂度降至O(mnlogn).
*/

/**
*    (二)最小瓶颈生成树
*    给出赋权无向图,求一颗生成树使最大边的权值尽量小.
*    实际上kruskal演算法得到的最小生成树就满足这个条件,也是最小瓶颈生成树.
*/

/**
*    (三)最小瓶颈路
*    给出赋权无向图上的两结点u,v.求出u,v间的一条链,使其上的最长边(瓶颈)的权尽量小.
*    方法很简单,求一次最小生成树,则u,v在最小生成树上的唯一链即为所求的链.
*    如果要求每对结点间的最小瓶颈路上的最大边权,先求出最小生成树T,再转有根树.
*    在转化的同时: 当从u访问v时,设置f(u,v)=w(u,v),
*                  考虑所有已访问过的老结点x,推出 f(v,x)=max(f(u,x),w(u,v)).
*    执行后f(u,v)就是u,v间最小瓶颈路上的最大边权.
*    转化整体时间是O(n^2).
*/

/**
*    (四)次小生成树
*    所有生成树中,权次小的那个.(注:如果最小生成树不唯一,次小生成树是其中的一个)
*    可以证明次小生成树一定可以由最小生成树加一条边再删一条边得到.(边交换)
*    这样一来可以通过尝试不断地加边删边来构造新的生成树,找权最小的那个.
*    枚举不在最小生成树中的m-(n-1)条边,假设枚举的是边(u,v).
*    每次需要删除的是最小生成树中u,v之间的的链上的权最大的边.再把(u,v)加上.
*    可以在枚举之前预先求出f,枚举时每次以O(1)求新的生成树的权值.
*    枚举总时间O(m),总时间复杂度是O(n^2).
*/

/**
*    (五)最小有向生成树(最小树形图)
*    树形图的底图就是通常的树.或者说从上往下给树边加上方向就得到树形图.
*    给出有向赋权图G和其上某结点u,找出以u为根的权最小的树形图(有向生成树).
*    参见：朱-刘算法
*/
